You are an Algo-Trading AI Bot: Professional Trading Strategist & Risk Manager  

Please write me the state-of-the-art LLM AI Agents based algo-trading program on Interactive Brokers based on the base coding project including structure and content I provide to you.
"""
here is the folder structure and the corresponding file content in each folder:
```
Directory Structure:
└── code/
    └── config/
        ├── config.json
        └── prompts/
            ├── news_filter.txt
            ├── sentiment_analysis.txt
    └── src/
        ├── main.py
        └── ai_agents/
            ├── aggressive_trader.py
            ├── base_agent.py
            ├── bear_researcher.py
            ├── blackboard.py
            ├── bull_researcher.py
            ├── conservative_trader.py
            ├── debate.py
            ├── ensemble_strategy.py
            ├── fundamental_analyst.py
            ├── market_sentiment.py
            ├── rl_trader.py
            ├── sentiment_analyst.py
            ├── technical_analyst.py
            ├── trader.py
        └── ibkr_client/
            ├── data_pipeline.py
            ├── ibkr_api.py
        └── risk_management/
            ├── adaptive_sizing.py
            ├── risk_manager.py
        └── strategies/
            ├── sma_crossover.py
            ├── strategy_base.py
            ├── transformer_strategy.py
        └── utils/
            ├── llm_client.py
            ├── market_hours.py

File Contents:

# code\config\config.json content:

    ```
{
    "ibkr": {
        "host": "127.0.0.1",
        "port": 7497,
        "client_id": 1
    },
    "stocks": {
        "NorthAmerica": ["NVDA"],
        "AsiaHK": []
    },
    "risk_parameters": {
        "max_position_size": 0.05,
        "max_daily_loss": 0.02,
        "order_size": 0.1
    }
}

    ```

# code\config\prompts\news_filter.txt content:

    ```

    ```

# code\config\prompts\sentiment_analysis.txt content:

    ```

    ```

# code\src\main.py content:

    ```
from apscheduler.schedulers.blocking import BlockingScheduler
from ibkr_client.ibkr_api import IBKRClient, load_config
from ibkr_client.data_pipeline import DataPipeline
from ai_agents.fundamental_analyst import FundamentalAnalyst
from ai_agents.sentiment_analyst import SentimentAnalyst
from ai_agents.technical_analyst import TechnicalAnalyst
from ai_agents.bull_researcher import BullResearcher
from ai_agents.bear_researcher import BearResearcher
from ai_agents.debate import Debate
from ai_agents.conservative_trader import ConservativeTrader
from ai_agents.aggressive_trader import AggressiveTrader
from ai_agents.rl_trader import RLTrader
from ai_agents.ensemble_strategy import ensemble_decision
from ai_agents.blackboard import Blackboard
from risk_management.risk_manager import RiskManager
from utils.market_hours import MarketHoursChecker
from ai_agents.base_agent import Agent

def main():
    config = load_config()
    ibkr_client = IBKRClient()
    data_pipeline = DataPipeline()
    blackboard = Blackboard()
    market_hours = MarketHoursChecker()

    # Initialize agents
    fundamental_analyst = FundamentalAnalyst("Fundamental Analyst", blackboard)
    sentiment_analyst = SentimentAnalyst("Sentiment Analyst", blackboard)
    technical_analyst = TechnicalAnalyst("Technical Analyst", blackboard)
    bull_researcher = BullResearcher("Bull Researcher", blackboard)
    bear_researcher = BearResearcher("Bear Researcher", blackboard)
    facilitator = Agent("Facilitator", blackboard)
    trader_agents = [
        ConservativeTrader("Conservative Trader", blackboard),
        AggressiveTrader("Aggressive Trader", blackboard),
        RLTrader("RL Trader", blackboard)
    ]
    risk_manager = RiskManager(ibkr_client, config['risk_parameters'])

    # Subscribe to market data for all symbols at startup
    for symbol in config['stocks']['NorthAmerica']:
        ibkr_client.subscribe_market_data(symbol)

    scheduler = BlockingScheduler()
    for symbol in config['stocks']['NorthAmerica']:
        scheduler.add_job(
            trading_cycle,
            'cron',
            day_of_week='mon-fri',
            hour='*',
            minute='*/5',
            args=[symbol, ibkr_client, data_pipeline, market_hours, blackboard, fundamental_analyst, sentiment_analyst, technical_analyst, bull_researcher, bear_researcher, facilitator, trader_agents, risk_manager]
        )
    scheduler.start()

def trading_cycle(symbol, ibkr_client, data_pipeline, market_hours, blackboard, fundamental_analyst, sentiment_analyst, technical_analyst, bull_researcher, bear_researcher, facilitator, trader_agents, risk_manager):
    if not market_hours.is_market_open('SMART'):
        print(f"Market closed for {symbol}.")
        return

    # Fetch data
    historical_data = data_pipeline.fetch_historical_data(symbol, "30 D", "5 mins")
    news = data_pipeline.fetch_news(symbol, "2024-01-01", "2024-12-31")
    social_media = data_pipeline.fetch_social_media(symbol, "2024-01-01", "2024-12-31")
    financials = data_pipeline.fetch_financial_statements(symbol)
    current_price = ibkr_client.get_current_price(symbol)
    if current_price is None:
        print(f"Unable to fetch current price for {symbol}.")
        return

    # Analysts process data
    fundamental_analyst.analyze(financials)
    sentiment_analyst.analyze(news + social_media)
    technical_analyst.analyze(historical_data)

    # Conduct debate
    debate = Debate(bull_researcher, bear_researcher, facilitator, blackboard)
    debate_outcome = debate.conduct_debate(symbol)

    # Traders decide
    for trader in trader_agents:
        trader.make_decision(symbol, debate_outcome)

    # Ensemble decision
    trader_decisions = [trader.blackboard.get_report(trader.name)["decision"] for trader in trader_agents]
    final_decision = ensemble_decision(trader_decisions)

    # Risk management and execution
    closes = [bar['close'] for bar in historical_data]
    approved, shares = risk_manager.approve_order(symbol, final_decision.upper(), closes, current_price)
    if final_decision != "hold" and approved:
        ibkr_client.place_order(symbol, final_decision.upper(), shares)
        print(f"Executed {final_decision} order for {symbol} with {shares} shares.")
    else:
        print(f"No trade executed for {symbol}.")

if __name__ == "__main__":
    main()
    ```

# code\src\ai_agents\aggressive_trader.py content:

    ```
from ai_agents.trader import Trader

class AggressiveTrader(Trader):
    def make_decision(self, symbol, debate_outcome):
        sentiment_report = self.blackboard.get_report("Sentiment Analyst")
        if debate_outcome == "bullish" or sentiment_report.get("sentiment") > 0:
            self.decision = "buy"
        else:
            self.decision = "sell"
        self.communicate({"decision": self.decision})
    ```

# code\src\ai_agents\base_agent.py content:

    ```
from utils.llm_client import LLMClient

class Agent:
    def __init__(self, name, blackboard):
        self.name = name
        self.blackboard = blackboard
        self.llm = LLMClient()

    def communicate(self, report):
        """Post analysis to the blackboard."""
        self.blackboard.post_report(self.name, report)

    def analyze(self, data):
        """Abstract method to be implemented by subclasses."""
        raise NotImplementedError
    ```

# code\src\ai_agents\bear_researcher.py content:

    ```
from ai_agents.base_agent import Agent

class BearResearcher(Agent):
    def generate_argument(self, symbol):
        prompt = f"As a bear researcher, argue why {symbol} is not a good investment based on available data."
        return self.llm.generate(prompt)
    ```

# code\src\ai_agents\blackboard.py content:

    ```
class Blackboard:
    def __init__(self):
        self.reports = {}

    def post_report(self, agent_name, report):
        self.reports[agent_name] = report

    def get_report(self, agent_name):
        return self.reports.get(agent_name, {})
    ```

# code\src\ai_agents\bull_researcher.py content:

    ```
from ai_agents.base_agent import Agent

class BullResearcher(Agent):
    def generate_argument(self, symbol):
        prompt = f"As a bull researcher, argue why {symbol} is a good investment based on available data."
        return self.llm.generate(prompt)
    ```

# code\src\ai_agents\conservative_trader.py content:

    ```
from ai_agents.trader import Trader

class ConservativeTrader(Trader):
    def make_decision(self, symbol, debate_outcome):
        tech_report = self.blackboard.get_report("Technical Analyst")
        if debate_outcome == "bullish" and tech_report.get("signal") == "buy":
            self.decision = "buy"
        else:
            self.decision = "hold"
        self.communicate({"decision": self.decision})
    ```

# code\src\ai_agents\debate.py content:

    ```
from ai_agents.bull_researcher import BullResearcher
from ai_agents.bear_researcher import BearResearcher

class Debate:
    def __init__(self, bull, bear, facilitator, blackboard):
        self.bull = bull
        self.bear = bear
        self.facilitator = facilitator
        self.blackboard = blackboard

    def conduct_debate(self, symbol):
        bull_arg = self.bull.generate_argument(symbol)
        bear_arg = self.bear.generate_argument(symbol)
        prompt = f"Evaluate these arguments:\nBull: {bull_arg}\nBear: {bear_arg}\nDecide: BULLISH/NEUTRAL/BEARISH."
        decision = self.facilitator.llm.generate(prompt)
        outcome = "bullish" if "BULLISH" in decision else "bearish" if "BEARISH" in decision else "neutral"
        self.blackboard.post_report("Debate", {"outcome": outcome})
        return outcome
    ```

# code\src\ai_agents\ensemble_strategy.py content:

    ```
def ensemble_decision(trader_decisions):
    votes = {"buy": 0, "sell": 0, "hold": 0}
    for decision in trader_decisions:
        votes[decision] += 1
    return max(votes, key=votes.get)
    ```

# code\src\ai_agents\fundamental_analyst.py content:

    ```
from ai_agents.base_agent import Agent

class FundamentalAnalyst(Agent):
    def analyze(self, data):
        prompt = f"Analyze the financial statements: {data}. Provide a report on valuation and growth potential."
        report = self.llm.generate(prompt)
        lines = report.splitlines()
        valuation = lines[0] if lines else "N/A"
        growth = lines[-1] if lines else "N/A"
        self.communicate({"valuation": valuation, "growth": growth})
    ```

# code\src\ai_agents\market_sentiment.py content:

    ```
import requests
from utils.llm_client import LLMClient

class SentimentAnalyzer:
    def __init__(self):
        self.llm = LLMClient()
        self.news_api_key = "YOUR_NEWSAPI_KEY"  # Replace with your NewsAPI key
        
    def get_real_time_sentiment(self, symbol):
        news = requests.get(
            f"https://newsapi.org/v2/everything?q={symbol}&apiKey={self.news_api_key}"
        ).json()
        
        prompt = f"""Analyze market sentiment for {symbol} from these headlines:
        {[article['title'] for article in news['articles'][:5]]}
        Output: BULLISH/NEUTRAL/BEARISH and 1-sentence reasoning"""
        
        analysis = self.llm.generate(prompt)
        return self._parse_sentiment(analysis)
    
    def _parse_sentiment(self, text):
        if "BULLISH" in text:
            return 1
        elif "BEARISH" in text:
            return -1
        return 0
    ```

# code\src\ai_agents\rl_trader.py content:

    ```
from ai_agents.trader import Trader
import torch
import torch.nn as nn

class TradingDQN(nn.Module):
    def __init__(self, input_size):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(input_size, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 3)  # [HOLD, BUY, SELL]
        )
    
    def forward(self, x):
        return self.net(x)

class RLTrader(Trader):
    def __init__(self, name, blackboard):
        super().__init__(name, blackboard)
        self.model = TradingDQN(input_size=4)  # Simplified state size

    def get_state(self, symbol):
        tech_report = self.blackboard.get_report("Technical Analyst") or {}
        sentiment_report = self.blackboard.get_report("Sentiment Analyst") or {}
        debate_report = self.blackboard.get_report("Debate") or {}
        state = [
            tech_report.get("sma_short", 0),
            tech_report.get("sma_long", 0),
            sentiment_report.get("sentiment", 0),
            1 if debate_report.get("outcome") == "bullish" else -1 if debate_report.get("outcome") == "bearish" else 0
        ]
        return torch.FloatTensor(state)

    def make_decision(self, symbol, debate_outcome):
        state = self.get_state(symbol)
        with torch.no_grad():
            q_values = self.model(state)
        action = torch.argmax(q_values).item()
        self.decision = ["hold", "buy", "sell"][action]
        self.communicate({"decision": self.decision})
    ```

# code\src\ai_agents\sentiment_analyst.py content:

    ```
from ai_agents.base_agent import Agent
import requests

class SentimentAnalyst(Agent):
    def __init__(self, name, blackboard):
        super().__init__(name, blackboard)
        self.news_api_key = "YOUR_NEWSAPI_KEY"  # Replace with your NewsAPI key

    def analyze(self, texts):
        prompt = f"Analyze sentiment of these texts: {texts}. Output: BULLISH/NEUTRAL/BEARISH and reasoning."
        sentiment = self.llm.generate(prompt)
        sentiment_value = 1 if "BULLISH" in sentiment else -1 if "BEARISH" in sentiment else 0
        self.communicate({"sentiment": sentiment_value, "reasoning": sentiment})
    ```

# code\src\ai_agents\technical_analyst.py content:

    ```
from ai_agents.base_agent import Agent
import pandas as pd
import ta

class TechnicalAnalyst(Agent):
    def analyze(self, data):
        df = pd.DataFrame(data)
        df['sma_short'] = ta.trend.sma_indicator(df['close'], window=50)
        df['sma_long'] = ta.trend.sma_indicator(df['close'], window=200)
        signal = "buy" if df['sma_short'].iloc[-1] > df['sma_long'].iloc[-1] else "sell"
        self.communicate({
            "signal": signal,
            "sma_short": df['sma_short'].iloc[-1],
            "sma_long": df['sma_long'].iloc[-1]
        })
    ```

# code\src\ai_agents\trader.py content:

    ```
from ai_agents.base_agent import Agent

class Trader(Agent):
    def make_decision(self, symbol, debate_outcome):
        raise NotImplementedError
    ```

# code\src\ibkr_client\data_pipeline.py content:

    ```
import requests
from ibkr_client.ibkr_api import IBKRClient

class DataPipeline:
    def __init__(self):
        self.ibkr_client = IBKRClient()
        self.news_api_key = "YOUR_NEWSAPI_KEY"  # Replace with your NewsAPI key

    def fetch_historical_data(self, symbol, duration, bar_size):
        """Fetch historical price data from IBKR."""
        return self.ibkr_client.get_historical_data(symbol, duration, bar_size)

    def fetch_news(self, symbol, start_date, end_date):
        """Fetch news articles using NewsAPI."""
        url = f"https://newsapi.org/v2/everything?q={symbol}&from={start_date}&to={end_date}&apiKey={self.news_api_key}"
        response = requests.get(url)
        return [article['title'] + ": " + article['description'] for article in response.json().get('articles', [])]

    def fetch_social_media(self, symbol, start_date, end_date):
        """Placeholder for social media data (e.g., Twitter API)."""
        # TODO: Implement with Twitter API or similar
        return []  # Mock data; replace with actual implementation

    def fetch_financial_statements(self, symbol):
        """Placeholder for financial statements (e.g., SEC EDGAR)."""
        # TODO: Implement with SEC EDGAR API or similar
        return {"revenue": "N/A", "net_income": "N/A"}  # Mock data; replace with actual implementation
    ```

# code\src\ibkr_client\ibkr_api.py content:

    ```
import threading
import time
from ibapi.client import EClient
from ibapi.wrapper import EWrapper
from ibapi.contract import Contract
from ibapi.order import Order
from ibapi.account_summary_tags import AccountSummaryTags
import json

def load_config():
    with open("code/config/config.json", "r") as f:
        return json.load(f)

class IBKRConnection(EWrapper, EClient):
    def __init__(self):
        EClient.__init__(self, self)
        self.account_data = {}
        self.positions = {}
        self.current_prices = {}
        self.reqId = 1
        self.next_order_id = None
        self.account_data_ready = threading.Event()
        self.historical_data = []
        self.historical_data_ready = threading.Event()
        self.reqId_to_symbol = {}
        self.subscribed_symbols = set()

    def nextValidId(self, orderId):
        self.next_order_id = orderId

    def updateAccountValue(self, key, value, currency, accountName):
        try:
            self.account_data[key] = float(value)
        except ValueError:
            self.account_data[key] = value
        if key == "NetLiquidation":
            self.account_data_ready.set()

    def position(self, account, contract, pos, avgCost):
        self.positions[contract.symbol] = {'position': pos, 'avg_cost': avgCost}

    def error(self, reqId, errorCode, errorString, advancedOrderRejectJson=""):
        if errorCode in [2104, 2106, 2158]:
            print(f"INFO: {errorString}")
        else:
            print(f"ERROR: Code {errorCode} - {errorString}")

    def tickPrice(self, reqId, tickType, price, attrib):
        if tickType == 4:  # Last price
            symbol = self.reqId_to_symbol.get(reqId)
            if symbol:
                self.current_prices[symbol] = price

    def historicalData(self, reqId, bar):
        self.historical_data.append({
            'date': bar.date,
            'open': bar.open,
            'high': bar.high,
            'low': bar.low,
            'close': bar.close,
            'volume': bar.volume
        })

    def historicalDataEnd(self, reqId, start, end):
        self.historical_data_ready.set()

class IBKRClient:
    def __init__(self):
        self.conn = IBKRConnection()
        self._connect()

    def _connect(self):
        config = load_config()
        self.conn.connect(config['ibkr']['host'], config['ibkr']['port'], config['ibkr']['client_id'])
        ib_thread = threading.Thread(target=self.conn.run, daemon=True)
        ib_thread.start()
        time.sleep(1)
        self._request_account_data()

    def _request_account_data(self):
        self.conn.reqAccountUpdates(True, "")
        self.conn.reqPositions()
        self.conn.account_data_ready.wait(timeout=10)

    def get_account_data(self):
        return self.conn.account_data

    def get_positions(self):
        return self.conn.positions

    def subscribe_market_data(self, symbol):
        if symbol not in self.conn.subscribed_symbols:
            contract = Contract()
            contract.symbol = symbol
            contract.secType = "STK"
            contract.exchange = "SMART"
            contract.currency = "USD"
            reqId = self.conn.reqId
            self.conn.reqId += 1
            self.conn.reqMktData(reqId, contract, "", False, False, [])
            self.conn.reqId_to_symbol[reqId] = symbol
            self.conn.subscribed_symbols.add(symbol)

    def get_current_price(self, symbol):
        if symbol not in self.conn.current_prices:
            self.subscribe_market_data(symbol)
            time.sleep(1)  # Wait for price update
        return self.conn.current_prices.get(symbol)

    def get_historical_data(self, symbol, duration, bar_size):
        contract = Contract()
        contract.symbol = symbol
        contract.secType = "STK"
        contract.exchange = "SMART"
        contract.currency = "USD"
        reqId = self.conn.reqId
        self.conn.reqId += 1
        self.conn.historical_data = []
        self.conn.historical_data_ready.clear()
        self.conn.reqHistoricalData(reqId, contract, "", duration, bar_size, "TRADES", 1, 1, False, [])
        self.conn.historical_data_ready.wait(timeout=10)
        return self.conn.historical_data

    def place_order(self, symbol, action, quantity):
        contract = Contract()
        contract.symbol = symbol
        contract.secType = "STK"
        contract.exchange = "SMART"
        contract.currency = "USD"
        order = Order()
        order.action = action
        order.orderType = "MKT"
        order.totalQuantity = quantity
        self.conn.placeOrder(self.conn.next_order_id, contract, order)
        self.conn.next_order_id += 1
    ```

# code\src\risk_management\adaptive_sizing.py content:

    ```
import numpy as np

class AdaptivePositionSizer:
    def __init__(self, volatility_lookback=20):
        self.volatility_lookback = volatility_lookback
        
    def calculate_fraction(self, historical_data):
        returns = np.diff(np.log(historical_data))
        volatility = np.std(returns[-self.volatility_lookback:])
        return min(0.2 / (volatility + 1e-8), 0.05)
    ```

# code\src\risk_management\risk_manager.py content:

    ```
from risk_management.adaptive_sizing import AdaptivePositionSizer

class RiskManager:
    def __init__(self, ibkr_client, config):
        self.ibkr_client = ibkr_client
        self.config = config
        self.sizer = AdaptivePositionSizer()

    def approve_order(self, symbol, action, historical_data, current_price):
        account_data = self.ibkr_client.get_account_data()
        positions = self.ibkr_client.get_positions()
        net_liq = account_data.get('NetLiquidation', 0)
        max_position_value = self.config['max_position_size'] * net_liq
        current_position = positions.get(symbol, {}).get('position', 0)
        current_position_value = current_position * current_price if current_position > 0 else 0

        if action == 'BUY':
            position_fraction = self.sizer.calculate_fraction(historical_data)
            position_value = position_fraction * net_liq
            shares = int(position_value / current_price)
            new_position_value = (current_position + shares) * current_price
            if new_position_value > max_position_value or account_data.get('AvailableFunds', 0) < (shares * current_price):
                return False, 0
            return True, shares
        elif action == 'SELL':
            if current_position > 0:
                return True, current_position  # Sell entire position
            return False, 0
    ```

# code\src\strategies\sma_crossover.py content:

    ```
import pandas as pd
import ta
from strategies.strategy_base import TradingStrategy

class SMACrossoverStrategy(TradingStrategy):
    def __init__(self, symbol, exchange, risk_manager, short_period=50, long_period=200):
        super().__init__(symbol, exchange, risk_manager)
        self.short_period = short_period
        self.long_period = long_period
        self.historical_data = pd.DataFrame()

    def on_bar(self, bar):
        self.historical_data = pd.concat([self.historical_data, pd.DataFrame([{
            'open': bar.open,
            'high': bar.high,
            'low': bar.low,
            'close': bar.close,
            'volume': bar.volume
        }])], ignore_index=True)

        if len(self.historical_data) > self.long_period:
            self.historical_data['sma_short'] = ta.trend.sma_indicator(
                self.historical_data['close'], self.short_period
            )
            self.historical_data['sma_long'] = ta.trend.sma_indicator(
                self.historical_data['close'], self.long_period
            )

            if self._cross_above():
                if self.risk_manager.approve_order(self.symbol, 'BUY'):
                    self._place_order('BUY')
            elif self._cross_below():
                if self.risk_manager.approve_order(self.symbol, 'SELL'):
                    self._place_order('SELL')

    def _cross_above(self):
        return (
            self.historical_data['sma_short'].iloc[-2] < self.historical_data['sma_long'].iloc[-2]
        ) and (
            self.historical_data['sma_short'].iloc[-1] > self.historical_data['sma_long'].iloc[-1]
        )

    def _cross_below(self):
        return (
            self.historical_data['sma_short'].iloc[-2] > self.historical_data['sma_long'].iloc[-2]
        ) and (
            self.historical_data['sma_short'].iloc[-1] < self.historical_data['sma_long'].iloc[-1]
        )

    def _place_order(self, action):
        print(f"[DEBUG] Placing {action} order on {self.symbol}.")
    ```

# code\src\strategies\strategy_base.py content:

    ```
from abc import ABC, abstractmethod

class TradingStrategy(ABC):
    def __init__(self, symbol, exchange, risk_manager):
        self.symbol = symbol
        self.exchange = exchange
        self.risk_manager = risk_manager
        
    @abstractmethod
    def on_bar(self, bar):
        pass
    ```

# code\src\strategies\transformer_strategy.py content:

    ```

    ```

# code\src\utils\llm_client.py content:

    ```
from openai import OpenAI

class LLMClient:
    def __init__(self, model="gpt-4-1106-preview"):
        self.client = OpenAI(api_key="YOUR_OPENAI_API_KEY")  # Replace with your OpenAI API key
        self.model = model
        
    def generate(self, prompt, temperature=0.3):
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[{"role": "user", "content": prompt}],
            temperature=temperature
        )
        return response.choices[0].message.content
    ```

# code\src\utils\market_hours.py content:

    ```
from datetime import datetime, time
import pytz

class MarketHoursChecker:
    def __init__(self):
        self.holidays = {
            'NorthAmerica': [
                '2024-01-01', '2024-01-15', '2024-02-19'
            ],
            'AsiaHK': [
                '2024-01-01', '2024-02-10'
            ]
        }
        
    def is_market_open(self, exchange):
        exchange_region_map = {"SMART": "NorthAmerica", "NYSE": "NorthAmerica", "NASDAQ": "NorthAmerica", "HKEX": "AsiaHK"}
        region = exchange_region_map.get(exchange, exchange)
        now = datetime.now(pytz.utc)
        if region == "NorthAmerica":
            return self._is_nyse_open(now)
        elif region == "AsiaHK":
            return self._is_hkex_open(now)
        return False

    def _is_nyse_open(self, dt):
        et = dt.astimezone(pytz.timezone('America/New_York'))
        if et.weekday() >= 5 or et.strftime('%Y-%m-%d') in self.holidays['NorthAmerica']:
            return False
        market_open, market_close = time(9, 30), time(16, 0)
        return market_open <= et.time() <= market_close

    def _is_hkex_open(self, dt):
        hkt = dt.astimezone(pytz.timezone('Asia/Hong_Kong'))
        if hkt.weekday() >= 5 or hkt.strftime('%Y-%m-%d') in self.holidays['AsiaHK']:
            return False
        market_open, market_close = time(9, 30), time(16, 0)
        return market_open <= hkt.time() <= market_close
    ```

```
Please help me modify the code such that It uses Alibaba Cloud Qwen model API. (Use free model first for experiment)
Thank you.