Directory Structure:
└── code/
    └── config/
        ├── config.json
        └── prompts/
            ├── news_filter.txt
            ├── sentiment_analysis.txt
    └── src/
        ├── main.py
        └── ai_agents/
            ├── aggressive_trader.py
            ├── base_agent.py
            ├── bear_researcher.py
            ├── blackboard.py
            ├── bull_researcher.py
            ├── conservative_trader.py
            ├── debate.py
            ├── ensemble_strategy.py
            ├── fundamental_analyst.py
            ├── market_sentiment.py
            ├── rl_trader.py
            ├── sentiment_analyst.py
            ├── technical_analyst.py
            ├── trader.py
        └── ibkr_client/
            ├── data_pipeline.py
            ├── ibkr_api.py
        └── risk_management/
            ├── adaptive_sizing.py
            ├── risk_manager.py
        └── strategies/
            ├── sma_crossover.py
            ├── strategy_base.py
            ├── transformer_strategy.py
        └── utils/
            ├── llm_client.py
            ├── market_hours.py

File Contents:

# code\config\config.json content:

    ```
{
    "ibkr": {
        "host": "127.0.0.1",
        "port": 7497,
        "client_id": 1
    },
    "stocks": {
        "NorthAmerica": ["NVDA"],
        "AsiaHK": []
    },
    "risk_parameters": {
        "max_position_size": 0.05,
        "max_daily_loss": 0.02,
        "order_size": 0.1
    }
}

    ```

# code\config\prompts\news_filter.txt content:

    ```

    ```

# code\config\prompts\sentiment_analysis.txt content:

    ```

    ```

# code\src\main.py content:

    ```
from apscheduler.schedulers.blocking import BlockingScheduler
from ibkr_client.ibkr_api import IBKRClient, load_config
from ibkr_client.data_pipeline import DataPipeline
from ai_agents.fundamental_analyst import FundamentalAnalyst
from ai_agents.sentiment_analyst import SentimentAnalyst
from ai_agents.technical_analyst import TechnicalAnalyst
from ai_agents.bull_researcher import BullResearcher
from ai_agents.bear_researcher import BearResearcher
from ai_agents.debate import Debate
from ai_agents.conservative_trader import ConservativeTrader
from ai_agents.aggressive_trader import AggressiveTrader
from ai_agents.rl_trader import RLTrader
from ai_agents.ensemble_strategy import ensemble_decision
from ai_agents.blackboard import Blackboard
from risk_management.risk_manager import RiskManager
from utils.market_hours import MarketHoursChecker

def main():
    config = load_config()
    ibkr_client = IBKRClient()
    data_pipeline = DataPipeline()
    blackboard = Blackboard()
    market_hours = MarketHoursChecker()

    # Initialize agents
    fundamental_analyst = FundamentalAnalyst("Fundamental Analyst", blackboard)
    sentiment_analyst = SentimentAnalyst("Sentiment Analyst", blackboard)
    technical_analyst = TechnicalAnalyst("Technical Analyst", blackboard)
    bull_researcher = BullResearcher("Bull Researcher", blackboard)
    bear_researcher = BearResearcher("Bear Researcher", blackboard)
    facilitator = Agent("Facilitator", blackboard)  # Reuses base agent for simplicity
    trader_agents = [
        ConservativeTrader("Conservative Trader", blackboard),
        AggressiveTrader("Aggressive Trader", blackboard),
        RLTrader("RL Trader", blackboard)
    ]
    risk_manager = RiskManager(ibkr_client, config['risk_parameters'])

    scheduler = BlockingScheduler()
    for symbol in config['stocks']['NorthAmerica']:
        scheduler.add_job(
            trading_cycle,
            'cron',
            day_of_week='mon-fri',
            hour='*',
            minute='*/5',
            args=[symbol, ibkr_client, data_pipeline, market_hours, blackboard, fundamental_analyst, sentiment_analyst, technical_analyst, bull_researcher, bear_researcher, facilitator, trader_agents, risk_manager]
        )
    scheduler.start()

def trading_cycle(symbol, ibkr_client, data_pipeline, market_hours, blackboard, fundamental_analyst, sentiment_analyst, technical_analyst, bull_researcher, bear_researcher, facilitator, trader_agents, risk_manager):
    if not market_hours.is_market_open('SMART'):
        print(f"Market closed for {symbol}.")
        return

    # Fetch data
    historical_data = data_pipeline.fetch_historical_data(symbol, "30 D", "1 min")
    news = data_pipeline.fetch_news(symbol, "2024-01-01", "2024-12-31")
    social_media = data_pipeline.fetch_social_media(symbol, "2024-01-01", "2024-12-31")
    financials = data_pipeline.fetch_financial_statements(symbol)

    # Analysts process data
    fundamental_analyst.analyze(financials)
    sentiment_analyst.analyze(news + social_media)
    technical_analyst.analyze(historical_data)

    # Conduct debate
    debate = Debate(bull_researcher, bear_researcher, facilitator)
    debate_outcome = debate.conduct_debate(symbol)

    # Traders decide
    for trader in trader_agents:
        trader.make_decision(symbol, debate_outcome)

    # Ensemble decision
    trader_decisions = [trader.blackboard.get_report(trader.name)["decision"] for trader in trader_agents]
    final_decision = ensemble_decision(trader_decisions)

    # Risk management and execution
    current_price = historical_data[-1]['close']  # Last close price
    if final_decision != "hold" and risk_manager.approve_order(symbol, final_decision.upper(), historical_data, current_price):
        ibkr_client.place_order(symbol, final_decision.upper())
        print(f"Executed {final_decision} order for {symbol}.")
    else:
        print(f"No trade executed for {symbol}.")

if __name__ == "__main__":
    main()
    ```

# code\src\ai_agents\aggressive_trader.py content:

    ```
from ai_agents.trader import Trader

class AggressiveTrader(Trader):
    def make_decision(self, symbol, debate_outcome):
        sentiment_report = self.blackboard.get_report("Sentiment Analyst")
        if debate_outcome == "bullish" or sentiment_report.get("sentiment") > 0:
            self.decision = "buy"
        else:
            self.decision = "sell"
        self.communicate({"decision": self.decision})
    ```

# code\src\ai_agents\base_agent.py content:

    ```
from utils.llm_client import LLMClient

class Agent:
    def __init__(self, name, blackboard):
        self.name = name
        self.blackboard = blackboard
        self.llm = LLMClient()

    def communicate(self, report):
        """Post analysis to the blackboard."""
        self.blackboard.post_report(self.name, report)

    def analyze(self, data):
        """Abstract method to be implemented by subclasses."""
        raise NotImplementedError
    ```

# code\src\ai_agents\bear_researcher.py content:

    ```
from ai_agents.base_agent import Agent

class BearResearcher(Agent):
    def generate_argument(self, symbol):
        prompt = f"As a bear researcher, argue why {symbol} is not a good investment based on available data."
        return self.llm.generate(prompt)
    ```

# code\src\ai_agents\blackboard.py content:

    ```
class Blackboard:
    def __init__(self):
        self.reports = {}

    def post_report(self, agent_name, report):
        self.reports[agent_name] = report

    def get_report(self, agent_name):
        return self.reports.get(agent_name, {})
    ```

# code\src\ai_agents\bull_researcher.py content:

    ```
from ai_agents.base_agent import Agent

class BullResearcher(Agent):
    def generate_argument(self, symbol):
        prompt = f"As a bull researcher, argue why {symbol} is a good investment based on available data."
        return self.llm.generate(prompt)
    ```

# code\src\ai_agents\conservative_trader.py content:

    ```
from ai_agents.trader import Trader

class ConservativeTrader(Trader):
    def make_decision(self, symbol, debate_outcome):
        tech_report = self.blackboard.get_report("Technical Analyst")
        if debate_outcome == "bullish" and tech_report.get("signal") == "buy":
            self.decision = "buy"
        else:
            self.decision = "hold"
        self.communicate({"decision": self.decision})
    ```

# code\src\ai_agents\debate.py content:

    ```
from ai_agents.bull_researcher import BullResearcher
from ai_agents.bear_researcher import BearResearcher

class Debate:
    def __init__(self, bull, bear, facilitator):
        self.bull = bull
        self.bear = bear
        self.facilitator = facilitator

    def conduct_debate(self, symbol):
        bull_arg = self.bull.generate_argument(symbol)
        bear_arg = self.bear.generate_argument(symbol)
        prompt = f"Evaluate these arguments:\nBull: {bull_arg}\nBear: {bear_arg}\nDecide: BULLISH/NEUTRAL/BEARISH."
        decision = self.facilitator.llm.generate(prompt)
        return "bullish" if "BULLISH" in decision else "bearish" if "BEARISH" in decision else "neutral"
    ```

# code\src\ai_agents\ensemble_strategy.py content:

    ```
def ensemble_decision(trader_decisions):
    votes = {"buy": 0, "sell": 0, "hold": 0}
    for decision in trader_decisions:
        votes[decision] += 1
    return max(votes, key=votes.get)
    ```

# code\src\ai_agents\fundamental_analyst.py content:

    ```
from ai_agents.base_agent import Agent

class FundamentalAnalyst(Agent):
    def analyze(self, data):
        prompt = f"Analyze the financial statements: {data}. Provide a report on valuation and growth potential."
        report = self.llm.generate(prompt)
        self.communicate({"valuation": report.splitlines()[0], "growth": report.splitlines()[-1]})
    ```

# code\src\ai_agents\market_sentiment.py content:

    ```
import requests
from llm_client import LLMClient

class SentimentAnalyzer:
    def __init__(self):
        self.llm = LLMClient()
        self.news_api_key = "YOUR_NEWSAPI_KEY"
        
    def get_real_time_sentiment(self, symbol):
        # Fetch latest news
        news = requests.get(
            f"https://newsapi.org/v2/everything?q={symbol}&apiKey={self.news_api_key}"
        ).json()
        
        # LLM Analysis
        prompt = f"""Analyze market sentiment for {symbol} from these headlines:
        {[article['title'] for article in news['articles'][:5]]}
        Output: BULLISH/NEUTRAL/BEARISH and 1-sentence reasoning"""
        
        analysis = self.llm.generate(prompt)
        return self._parse_sentiment(analysis)
    
    def _parse_sentiment(self, text):
        # Implement LLM output parsing
        if "BULLISH" in text: return 1
        elif "BEARISH" in text: return -1
        return 0
    ```

# code\src\ai_agents\rl_trader.py content:

    ```
from ai_agents.trader import Trader
import torch
import torch.nn as nn

class TradingDQN(nn.Module):
    def __init__(self, input_size):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(input_size, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 3)  # [HOLD, BUY, SELL]
        )
    
    def forward(self, x):
        return self.net(x)

class RLTrader(Trader):
    def __init__(self, name, blackboard):
        super().__init__(name, blackboard)
        self.model = TradingDQN(input_size=14)  # Adjust input size based on state

    def get_state(self, symbol):
        # Mock state: combine technical, sentiment, and debate data
        return torch.FloatTensor([0.0] * 14)  # Implement actual state extraction

    def make_decision(self, symbol, debate_outcome):
        state = self.get_state(symbol)
        with torch.no_grad():
            q_values = self.model(state)
        action = torch.argmax(q_values).item()
        self.decision = ["hold", "buy", "sell"][action]
        self.communicate({"decision": self.decision})
    ```

# code\src\ai_agents\sentiment_analyst.py content:

    ```
from ai_agents.base_agent import Agent
import requests

class SentimentAnalyst(Agent):
    def __init__(self, name, blackboard):
        super().__init__(name, blackboard)
        self.news_api_key = "YOUR_NEWSAPI_KEY"

    def analyze(self, texts):
        prompt = f"Analyze sentiment of these texts: {texts}. Output: BULLISH/NEUTRAL/BEARISH and reasoning."
        sentiment = self.llm.generate(prompt)
        sentiment_value = 1 if "BULLISH" in sentiment else -1 if "BEARISH" in sentiment else 0
        self.communicate({"sentiment": sentiment_value, "reasoning": sentiment})
    ```

# code\src\ai_agents\technical_analyst.py content:

    ```
from ai_agents.base_agent import Agent
import pandas as pd
import ta

class TechnicalAnalyst(Agent):
    def analyze(self, data):
        df = pd.DataFrame(data)
        df['sma_short'] = ta.trend.sma_indicator(df['close'], window=50)
        df['sma_long'] = ta.trend.sma_indicator(df['close'], window=200)
        signal = "buy" if df['sma_short'].iloc[-1] > df['sma_long'].iloc[-1] else "sell"
        self.communicate({"signal": signal, "indicators": {"sma_short": df['sma_short'].iloc[-1], "sma_long": df['sma_long'].iloc[-1]}})
    ```

# code\src\ai_agents\trader.py content:

    ```
from ai_agents.base_agent import Agent

class Trader(Agent):
    def make_decision(self, symbol, debate_outcome):
        raise NotImplementedError
    ```

# code\src\ibkr_client\data_pipeline.py content:

    ```
import requests
from ibkr_client.ibkr_api import IBKRClient

class DataPipeline:
    def __init__(self):
        self.ibkr_client = IBKRClient()
        self.news_api_key = "YOUR_NEWSAPI_KEY"  # Replace with actual key

    def fetch_historical_data(self, symbol, start_date, end_date):
        """Fetch historical price data from IBKR."""
        return self.ibkr_client.get_historical_data(symbol, start_date, end_date)

    def fetch_news(self, symbol, start_date, end_date):
        """Fetch news articles using NewsAPI."""
        url = f"https://newsapi.org/v2/everything?q={symbol}&from={start_date}&to={end_date}&apiKey={self.news_api_key}"
        response = requests.get(url)
        return [article['title'] + ": " + article['description'] for article in response.json().get('articles', [])]

    def fetch_social_media(self, symbol, start_date, end_date):
        """Placeholder for social media data (e.g., Twitter API)."""
        # Implement Twitter/Reddit API calls here
        return []  # Mock data for now

    def fetch_financial_statements(self, symbol):
        """Placeholder for financial statements (e.g., SEC EDGAR)."""
        # Implement API or scraping logic
        return {"revenue": "N/A", "net_income": "N/A"}  # Mock data
    ```

# code\src\ibkr_client\ibkr_api.py content:

    ```
import threading
import time
from ibapi.client import EClient
from ibapi.wrapper import EWrapper
from ibapi.contract import Contract
from ibapi.account_summary_tags import AccountSummaryTags
import random

def load_config():
    # NOTE: Provide the actual implementation or import from a shared config loader
    import json
    with open("code/config/config.json", "r") as f:
        return json.load(f)

class IBKRConnection(EWrapper, EClient):
    def __init__(self):
        EClient.__init__(self, self)
        self.account_data = {}
        self.positions = {}
        self.reqId = 1
        self.next_order_id = None
        self.account_data_ready = threading.Event()

    def nextValidId(self, orderId):
        self.next_order_id = orderId

    def updateAccountValue(self, key, value, currency, accountName):
        """
        Store each key/value in a dictionary for later use/printing.
        Example keys: 'AvailableFunds', 'NetLiquidation', 'BuyingPower', etc.
        """
        try:
            # Attempt to store as float if numeric
            self.account_data[key] = float(value)
        except ValueError:
            # Otherwise, store as string
            self.account_data[key] = value
        if key == "NetLiquidation":  # Final key in updates
            self.account_data_ready.set()
    def position(self, account, contract, pos, avgCost):
        self.positions[contract.symbol] = {
            'position': pos,
            'avg_cost': avgCost
        }
    def error(self, reqId, errorCode, errorString, advancedOrderRejectJson=""):
        if errorCode in [2104, 2106, 2158]:
            print(f"INFO: {errorString}")  # Demote to informational message
        else:
            print(f"ERROR: Code {errorCode} - {errorString}")

class IBKRClient:
    def __init__(self):
        self.conn = IBKRConnection()
        self._connect()

    def _connect(self):
        config = load_config()
        self.conn.connect(
            config['ibkr']['host'],
            config['ibkr']['port'],
            config['ibkr']['client_id']
        )
        ib_thread = threading.Thread(target=self._run_loop, daemon=True)
        ib_thread.start()
        time.sleep(1)
        self._request_account_data()

    def _run_loop(self):
        self.conn.run()

    def _request_account_data(self):
        # Request account values & positions
        # self.conn.reqMarketDataType(3)
        self.conn.reqAccountUpdates(True, "")
        self.conn.reqPositions()
        self.conn.account_data_ready.wait(timeout=10)

    def get_account_data(self):
        """
        Returns the entire account_data dictionary.
        """
        return self.conn.account_data

    def get_positions(self):
        """
        Returns the positions dictionary.
        """
        return self.conn.positions

    def get_realtime_bars(self, symbol):
        """
        Placeholder for real-time bar data retrieval.
        You would implement TWS API calls here.
        """
        # For illustration, returning a mock bar
        # In production, you'd subscribe to real-time bars from IBKR
        class Bar:
            def __init__(self, open, high, low, close, volume):
                self.open = open
                self.high = high
                self.low = low
                self.close = close
                self.volume = volume
        # Generate slightly varying prices
        close = 200 + random.randint(-5, 5)
        return [Bar(200.0, 202.0, 198.0, close, 10000)]


    def _handle_data_farm_disconnect(self):
        print("Reconnecting to market data...")
        self._request_account_data()  # Re-request account/positions
        # Re-subscribe to real-time data streams here
    ```

# code\src\risk_management\adaptive_sizing.py content:

    ```
import numpy as np

class AdaptivePositionSizer:
    def __init__(self, volatility_lookback=20):
        self.volatility_lookback = volatility_lookback
        
    def calculate_size(self, historical_data, current_price):
        returns = np.diff(np.log(historical_data))
        volatility = np.std(returns[-self.volatility_lookback:])
        base_size = min(0.2 / (volatility + 1e-8), 0.05)
        return base_size * current_price  # Adjusted for account size
    ```

# code\src\risk_management\risk_manager.py content:

    ```
from risk_management.adaptive_sizing import AdaptivePositionSizer

class RiskManager:
    def __init__(self, ibkr_client, config):
        self.ibkr_client = ibkr_client
        self.config = config
        self.sizer = AdaptivePositionSizer()

    def approve_order(self, symbol, action, historical_data, current_price):
        account_data = self.ibkr_client.get_account_data()
        positions = self.ibkr_client.get_positions()
        net_liq = account_data.get('NetLiquidation', 0)
        max_size = self.config['max_position_size'] * net_liq
        current_position = positions.get(symbol, {}).get('position', 0)
        order_size = self.sizer.calculate_size(historical_data, current_price)

        if action == 'BUY':
            if account_data.get('AvailableFunds', 0) <= 0 or (current_position + order_size) > max_size:
                return False
        if action == 'SELL':
            if abs(current_position - order_size) > max_size:
                return False
        return True
    ```

# code\src\strategies\sma_crossover.py content:

    ```
import pandas as pd
import ta
from .strategy_base import TradingStrategy  # <-- Add this line

class SMACrossoverStrategy(TradingStrategy):
    def __init__(self, symbol, exchange, risk_manager, short_period=50, long_period=200):
        super().__init__(symbol, exchange, risk_manager)
        self.short_period = short_period
        self.long_period = long_period
        self.historical_data = pd.DataFrame()

    def on_bar(self, bar):
        self.historical_data = self.historical_data.append({
            'open': bar.open,
            'high': bar.high,
            'low': bar.low,
            'close': bar.close,
            'volume': bar.volume
        }, ignore_index=True)

        if len(self.historical_data) > self.long_period:
            self.historical_data['sma_short'] = ta.trend.sma_indicator(
                self.historical_data['close'], self.short_period
            )
            self.historical_data['sma_long'] = ta.trend.sma_indicator(
                self.historical_data['close'], self.long_period
            )

            if self._cross_above():
                if self.risk_manager.approve_order(self.symbol, 'BUY'):
                    self._place_order('BUY')
            elif self._cross_below():
                if self.risk_manager.approve_order(self.symbol, 'SELL'):
                    self._place_order('SELL')

    def _cross_above(self):
        return (
            self.historical_data['sma_short'].iloc[-2] <
            self.historical_data['sma_long'].iloc[-2]
        ) and (
            self.historical_data['sma_short'].iloc[-1] >
            self.historical_data['sma_long'].iloc[-1]
        )

    def _cross_below(self):
        return (
            self.historical_data['sma_short'].iloc[-2] >
            self.historical_data['sma_long'].iloc[-2]
        ) and (
            self.historical_data['sma_short'].iloc[-1] <
            self.historical_data['sma_long'].iloc[-1]
        )

    def _place_order(self, action):
        """Placeholder for placing an actual IB order."""
        print(f"[DEBUG] Placing {action} order on {self.symbol}.")

    ```

# code\src\strategies\strategy_base.py content:

    ```
from abc import ABC, abstractmethod

class TradingStrategy(ABC):
    def __init__(self, symbol, exchange, risk_manager):
        self.symbol = symbol
        self.exchange = exchange
        self.risk_manager = risk_manager
        
    @abstractmethod
    def on_bar(self, bar):
        pass
    ```

# code\src\strategies\transformer_strategy.py content:

    ```

    ```

# code\src\utils\llm_client.py content:

    ```
from openai import OpenAI

class LLMClient:
    def __init__(self, model="gpt-4-1106-preview"):
        self.client = OpenAI()
        self.model = model
        
    def generate(self, prompt, temperature=0.3):
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[{"role": "user", "content": prompt}],
            temperature=temperature
        )
        return response.choices[0].message.content
    ```

# code\src\utils\market_hours.py content:

    ```
# code/src/utils/market_hours.py

from datetime import datetime, time
import pytz
from dateutil import parser

class MarketHoursChecker:
    def __init__(self):
        self.holidays = {  # Basic holiday template (expand as needed)
            'NorthAmerica': [
                '2024-01-01',  # New Year's
                '2024-01-15',  # MLK Day
                '2024-02-19',  # Presidents Day
                # Add other NYSE holidays
            ],
            'AsiaHK': [
                '2024-01-01',  # New Year
                '2024-02-10',  # Lunar New Year
                # Add other HKEX holidays
            ]
        }
        
    def is_market_open(self, exchange: str) -> bool:
        """Check if market is open based on exchange and current time."""
        # Map IBKR exchange codes to regions
        exchange_region_map = {
            "SMART": "NorthAmerica",
            "NYSE": "NorthAmerica",
            "NASDAQ": "NorthAmerica",
            "HKEX": "AsiaHK"
        }
        region = exchange_region_map.get(exchange, exchange)
        if region not in ["NorthAmerica", "AsiaHK"]:
            raise ValueError(f"Unsupported exchange: {exchange}")

        now = datetime.now(pytz.utc)

        if region == "NorthAmerica":
            return self._is_nyse_open(now)
        elif region == "AsiaHK":
            return self._is_hkex_open(now)
        else:
            return False

    def _is_nyse_open(self, dt: datetime) -> bool:
        """NYSE trading hours 9:30 AM - 4:00 PM ET, Mon-Fri"""
        et = dt.astimezone(pytz.timezone('America/New_York'))
        
        # Check weekday
        if et.weekday() >= 5:  # Saturday(5) or Sunday(6)
            return False
            
        # Check holidays
        date_str = et.strftime('%Y-%m-%d')
        if date_str in self.holidays['NorthAmerica']:
            return False
            
        # Check time
        market_open = time(9, 30)
        market_close = time(16, 0)
        return market_open <= et.time() <= market_close

    def _is_hkex_open(self, dt: datetime) -> bool:
        """HKEX trading hours 9:30 AM - 4:00 PM HKT, Mon-Fri"""
        hkt = dt.astimezone(pytz.timezone('Asia/Hong_Kong'))
        
        if hkt.weekday() >= 5:
            return False
            
        date_str = hkt.strftime('%Y-%m-%d')
        if date_str in self.holidays['AsiaHK']:
            return False
            
        market_open = time(9, 30)
        market_close = time(16, 0)
        return market_open <= hkt.time() <= market_close

    def add_custom_holiday(self, exchange: str, date_str: str):
        """Add custom holiday dates (YYYY-MM-DD format)"""
        try:
            parsed_date = parser.parse(date_str).date()
            self.holidays[exchange].append(date_str)
        except ValueError:
            raise ValueError(f"Invalid date format: {date_str}. Use YYYY-MM-DD")
    def is_market_open(self, exchange: str) -> bool:
        # Map IBKR exchange codes to regions
        exchange_region_map = {
            "SMART": "NorthAmerica",  # Assuming SMART is used for North American stocks
            "NYSE": "NorthAmerica",
            "NASDAQ": "NorthAmerica",
            "HKEX": "AsiaHK"
        }
        region = exchange_region_map.get(exchange, exchange)
        if region not in ["NorthAmerica", "AsiaHK"]:
            raise ValueError(f"Unsupported exchange: {exchange}")
        
        # Rest of the method remains the same
        if region == "NorthAmerica":
            return self._is_nyse_open(now)
        elif region == "AsiaHK":
            return self._is_hkex_open(now)
    ```
